<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>CYBR FRNDZ</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0f; overflow: hidden; display: flex; align-items: center; justify-content: center; height: 100vh; font-family: 'Share Tech Mono', monospace; }
#game-container { position: relative; }
canvas { display: block; image-rendering: pixelated; }
/* Loading screen */
#loading { position: fixed; inset: 0; background: #0a0a0f; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; transition: opacity 0.5s; }
#loading.hidden { opacity: 0; pointer-events: none; }
#loading h1 { font-family: 'Orbitron', sans-serif; font-size: 2.5rem; margin-bottom: 8px; }
#loading .cf-c { color: #00f0ff; text-shadow: 0 0 15px #00f0ff; }
#loading .cf-f { color: #ff00aa; text-shadow: 0 0 15px #ff00aa; margin-left: -8px; }
#loading p { color: #8888aa; font-size: 0.9rem; margin-top: 16px; }
#loading .bar-outer { width: 200px; height: 4px; background: #111; margin-top: 24px; border: 1px solid rgba(0,240,255,0.2); }
#loading .bar-inner { height: 100%; width: 0%; background: linear-gradient(90deg, #00f0ff, #ff00aa); transition: width 0.3s; }
</style>
</head>
<body>
<div id="loading">
  <h1><span class="cf-c">C</span><span class="cf-f">F</span></h1>
  <p>LOADING NEON DISTRICT...</p>
  <div class="bar-outer"><div class="bar-inner" id="loadBar"></div></div>
</div>
<div id="game-container"></div>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
<script>
// ============================================================
// CYBR FRNDZ â€” Main Game
// Minecraft Ã— Animal Crossing Ã— Tron
// ============================================================

// -- CONSTANTS --
const TILE = 32;
const CITY_W = 40;
const CITY_H = 30;
const COLORS = {
  cyan: 0x00f0ff, magenta: 0xff00aa, purple: 0xa855f7,
  green: 0x00ff88, yellow: 0xffe600, pink: 0xff2d95,
  bg: 0x0a0a0f, bg2: 0x0d0d18, grid: 0x111126,
  road: 0x0a0a14, wall: 0x0d0d20
};

// -- SAVE SYSTEM --
const Save = {
  data: {
    rp: 500,
    inventory: [],
    room: [],
    friends: [],
    name: 'PLAYER',
    avatar: { skin: 0x00f0ff, outfit: 0xa855f7, acc: null },
    quests: {},
    visited: {},
    day: 1
  },
  load() {
    try {
      const s = localStorage.getItem('cybrfrndz_save');
      if (s) Object.assign(this.data, JSON.parse(s));
    } catch(e) {}
  },
  save() {
    try { localStorage.setItem('cybrfrndz_save', JSON.stringify(this.data)); } catch(e) {}
  },
  earnRP(amount) { this.data.rp += amount; this.save(); },
  spendRP(amount) {
    if (this.data.rp < amount) return false;
    this.data.rp -= amount; this.save(); return true;
  }
};
Save.load();

// -- DIALOGUE DATA --
const DIALOGUES = {
  pixel: {
    name: 'PIXEL', color: 0x00f0ff, emoji: 'ðŸŽ¨',
    lines: [
      { text: "Hey there, frnd! Welcome to Neon District!", responses: ["Thanks! Cool place.", "Who are you?"] },
      { text: "I'm Pixel â€” the resident artist around here. Everything's a canvas if you're brave enough!", responses: ["I like that vibe!", "Can I see your apartment?"] },
      { text: "You should totally decorate your apartment! Express yourself. That's what RP is for.", responses: ["How do I earn RP?", "I will!"] },
      { text: "Earn RP by tapping friends IRL! Or help me out â€” I've got a challenge for you.", responses: ["What challenge?", "Maybe later."] },
      { text: "Decorate your room with at least 5 items and I'll give you 50 bonus RP. Deal?", responses: ["Deal!", "I'll think about it."] },
    ],
    quest: { id: 'pixel_decorate', desc: 'Place 5 items in your apartment', target: 5, reward: 50 }
  },
  nova: {
    name: 'NOVA', color: 0xa855f7, emoji: 'ðŸ”§',
    lines: [
      { text: "Oh! A visitor. Fascinating. Did you know NFC operates at 13.56 MHz?", responses: ["That IS cool!", "Um, sure?"] },
      { text: "I'm Nova. I build things. Circuits, gadgets, the occasional hologram projector.", responses: ["Teach me!", "Nice apartment."] },
      { text: "Your wristband is basically a tiny computer. The RFID chip stores your tap data offline.", responses: ["How many taps?", "Wow."] },
      { text: "About 1,000 taps! Then you sync at home. I designed the sync protocol myself.", responses: ["Impressive!", "Can you help me?"] },
      { text: "Tell you what â€” explore the whole district and I'll craft you something special. 75 RP.", responses: ["I'll explore!", "Not now."] },
    ],
    quest: { id: 'nova_explore', desc: 'Visit all 4 buildings in the district', target: 4, reward: 75 }
  },
  glitch: {
    name: 'GLITCH', color: 0x00ff88, emoji: 'ðŸŽµ',
    lines: [
      { text: "Yooo what's good! You hear that beat? That's my latest mix.", responses: ["Sounds amazing!", "It's... loud."] },
      { text: "Haha yeah it's loud. That's the POINT. I'm Glitch â€” DJ, producer, vibe curator.", responses: ["Love the setup!", "Teach me to DJ!"] },
      { text: "Life's a beat, frnd. You just gotta find your rhythm. Know what I mean?", responses: ["Deep.", "Not really lol."] },
      { text: "Ha! Fair. Hey, help me test something â€” place a speaker in your room and crank it.", responses: ["On it!", "What's in it for me?"] },
      { text: "I'll hook you up with 40 RP AND a rare LED strip. The GOOD one. Deal?", responses: ["Deal!", "Maybe later."] },
    ],
    quest: { id: 'glitch_speaker', desc: 'Place a speaker in your apartment', target: 1, reward: 40 }
  },
  echo: {
    name: 'ECHO', color: 0xffe600, emoji: 'ðŸ—ºï¸',
    lines: [
      { text: "...oh. You found me. Most people walk right past.", responses: ["Hard to miss you!", "Who are you?"] },
      { text: "I'm Echo. I explore. Map things. Find secrets. This district has more than you'd think.", responses: ["Like what?", "Secrets?"] },
      { text: "Like... there's a hidden message in the park. And a rare item behind the arcade.", responses: ["Tell me more!", "I'll find them myself."] },
      { text: "That's the spirit. Explorers don't need directions â€” they need curiosity.", responses: ["I'm curious!", "Give me a hint?"] },
      { text: "Fine, one hint: the neon trees aren't all the same color. Find the odd one out. 60 RP.", responses: ["Challenge accepted!", "Later."] },
    ],
    quest: { id: 'echo_secret', desc: 'Find the hidden item in the park', target: 1, reward: 60 }
  },
  byte: {
    name: 'BYTE', color: 0xff00aa, emoji: 'ðŸ›’',
    lines: [
      { text: "Welcome, welcome, WELCOME to Byte's Bargains! Best deals in Neon District!", responses: ["What do you sell?", "Hey Byte!"] },
      { text: "Furniture, decorations, rare finds â€” if it glows, I got it. Check the shop!", responses: ["Show me!", "Just browsing."] },
      { text: "Pro tip: come back every day. I rotate my inventory. Today's deal won't last!", responses: ["Good to know!", "What's today's deal?"] },
      { text: "Hologram projector â€” normally 60 RP, today ONLY... 45 RP. You won't find it cheaper!", responses: ["I'll take it!", "Too rich for me."] },
    ]
  },
  mrs_circuit: {
    name: 'MRS. CIRCUIT', color: 0x7b5cff, emoji: 'ðŸ“š',
    lines: [
      { text: "Good day, student! Learning never stops â€” even in Neon District.", responses: ["Hi Mrs. Circuit!", "Are you a teacher?"] },
      { text: "Indeed I am. And the best lesson? Kindness compounds. Every tap, every friendship â€” it adds up.", responses: ["That's beautiful.", "How so?"] },
      { text: "When you're kind to someone, they're kind to someone else. It's exponential growth!", responses: ["Math AND kindness!", "I'll remember that."] },
    ]
  }
};

// -- FURNITURE DATA --
const FURNITURE = [
  { id: 'bed', name: 'Bed', cost: 30, w: 2, h: 1, color: COLORS.purple, desc: 'Cozy neon bed' },
  { id: 'desk', name: 'Desk', cost: 25, w: 2, h: 1, color: COLORS.cyan, desc: 'Work station' },
  { id: 'pc', name: 'PC', cost: 40, w: 1, h: 1, color: COLORS.cyan, desc: 'Gaming rig' },
  { id: 'neon_sign', name: 'Neon Sign', cost: 20, w: 2, h: 1, color: COLORS.magenta, desc: 'Custom glow sign' },
  { id: 'speaker', name: 'Speaker', cost: 15, w: 1, h: 1, color: COLORS.magenta, desc: 'Bass cannon' },
  { id: 'plant', name: 'Neon Plant', cost: 10, w: 1, h: 1, color: COLORS.green, desc: 'Bioluminescent' },
  { id: 'led_strip', name: 'LED Strip', cost: 15, w: 2, h: 1, color: COLORS.cyan, desc: 'RGB vibes' },
  { id: 'poster', name: 'Poster', cost: 8, w: 1, h: 1, color: COLORS.purple, desc: 'Wall art' },
  { id: 'hologram', name: 'Hologram', cost: 50, w: 1, h: 2, color: COLORS.cyan, desc: 'Floating display' },
  { id: 'shelf', name: 'Shelf', cost: 10, w: 2, h: 1, color: COLORS.cyan, desc: 'Display shelf' },
  { id: 'rug', name: 'Rug', cost: 12, w: 2, h: 2, color: COLORS.purple, desc: 'Soft glow carpet' },
  { id: 'chair', name: 'Chair', cost: 20, w: 1, h: 1, color: COLORS.purple, desc: 'Gaming throne' },
  { id: 'lamp', name: 'Lamp', cost: 12, w: 1, h: 1, color: COLORS.cyan, desc: 'Ambient light' },
  { id: 'crate', name: 'Crate', cost: 5, w: 1, h: 1, color: COLORS.cyan, desc: 'Storage box' },
  { id: 'disco', name: 'Disco Ball', cost: 35, w: 1, h: 1, color: COLORS.magenta, desc: 'Party time!' },
  { id: 'arcade', name: 'Arcade Cabinet', cost: 100, w: 1, h: 2, color: COLORS.green, desc: 'Retro gaming' },
  { id: 'dj_deck', name: 'DJ Deck', cost: 80, w: 2, h: 1, color: COLORS.magenta, desc: 'Drop the beat' },
  { id: 'telescope', name: 'Telescope', cost: 60, w: 1, h: 1, color: COLORS.yellow, desc: 'Stargazer' },
];

// -- NPC ROOM LAYOUTS --
const NPC_ROOMS = {
  pixel: [
    { id: 'desk', x: 1, y: 1 }, { id: 'pc', x: 3, y: 1 }, { id: 'poster', x: 5, y: 0 },
    { id: 'poster', x: 7, y: 0 }, { id: 'neon_sign', x: 8, y: 1 }, { id: 'rug', x: 4, y: 4 },
    { id: 'plant', x: 0, y: 6 }, { id: 'lamp', x: 10, y: 1 }, { id: 'chair', x: 2, y: 2 },
  ],
  nova: [
    { id: 'desk', x: 0, y: 1 }, { id: 'pc', x: 2, y: 1 }, { id: 'pc', x: 8, y: 1 },
    { id: 'hologram', x: 5, y: 2 }, { id: 'shelf', x: 0, y: 0 }, { id: 'shelf', x: 6, y: 0 },
    { id: 'crate', x: 10, y: 6 }, { id: 'crate', x: 10, y: 5 }, { id: 'led_strip', x: 3, y: 0 },
  ],
  glitch: [
    { id: 'dj_deck', x: 4, y: 1 }, { id: 'speaker', x: 0, y: 1 }, { id: 'speaker', x: 10, y: 1 },
    { id: 'speaker', x: 0, y: 5 }, { id: 'speaker', x: 10, y: 5 }, { id: 'led_strip', x: 2, y: 0 },
    { id: 'led_strip', x: 7, y: 0 }, { id: 'disco', x: 5, y: 4 }, { id: 'rug', x: 3, y: 5 },
  ],
  echo: [
    { id: 'bed', x: 8, y: 6 }, { id: 'telescope', x: 0, y: 1 }, { id: 'crate', x: 3, y: 3 },
    { id: 'lamp', x: 10, y: 1 }, { id: 'shelf', x: 4, y: 0 }, { id: 'plant', x: 7, y: 1 },
  ]
};

// -- CITY MAP DATA --
// 0=road, 1=sidewalk, 2=building, 3=park, 4=door, 5=plaza
function generateCityMap() {
  const map = Array.from({ length: CITY_H }, () => Array(CITY_W).fill(0));
  
  // Fill base with road
  for (let y = 0; y < CITY_H; y++)
    for (let x = 0; x < CITY_W; x++)
      map[y][x] = 0;
  
  // Sidewalks along roads
  for (let y = 0; y < CITY_H; y++)
    for (let x = 0; x < CITY_W; x++) {
      if (y % 8 < 2 || x % 10 < 2) map[y][x] = 1; // road grid
    }
  
  // Buildings (solid blocks)
  const buildings = [
    // Player apartment
    { x: 3, y: 3, w: 6, h: 4, id: 'player', name: 'YOUR APT', color: COLORS.yellow, doorX: 6, doorY: 7 },
    // Pixel's apartment  
    { x: 13, y: 3, w: 6, h: 4, id: 'pixel', name: "PIXEL'S PAD", color: COLORS.cyan, doorX: 16, doorY: 7 },
    // Nova's apartment
    { x: 3, y: 11, w: 6, h: 4, id: 'nova', name: "NOVA'S LAB", color: COLORS.purple, doorX: 6, doorY: 15 },
    // Glitch's apartment
    { x: 13, y: 11, w: 6, h: 4, id: 'glitch', name: "GLITCH'S DEN", color: COLORS.green, doorX: 16, doorY: 15 },
    // Echo's apartment
    { x: 23, y: 3, w: 6, h: 4, id: 'echo', name: "ECHO'S HIDEOUT", color: COLORS.yellow, doorX: 26, doorY: 7 },
    // Shop
    { x: 23, y: 11, w: 6, h: 4, id: 'shop', name: "BYTE'S SHOP", color: COLORS.magenta, doorX: 26, doorY: 15 },
  ];
  
  buildings.forEach(b => {
    for (let y = b.y; y < b.y + b.h; y++)
      for (let x = b.x; x < b.x + b.w; x++)
        map[y][x] = 2;
    // Door
    map[b.doorY] = map[b.doorY] || [];
    map[b.doorY][b.doorX] = 4;
  });
  
  // Park area
  for (let y = 19; y < 26; y++)
    for (let x = 3; x < 18; x++)
      map[y][x] = 3;

  // Plaza
  for (let y = 19; y < 26; y++)
    for (let x = 20; x < 35; x++)
      map[y][x] = 5;
  
  return { map, buildings };
}

const cityData = generateCityMap();

// ============================================================
// BOOT SCENE â€” Preload & Generate Assets
// ============================================================
class BootScene extends Phaser.Scene {
  constructor() { super('Boot'); }
  
  preload() {
    // We generate all sprites procedurally â€” no external assets needed for MVP
    this.load.on('progress', v => {
      document.getElementById('loadBar').style.width = (v * 100) + '%';
    });
  }
  
  create() {
    // Generate sprite textures
    this.generatePlayerSprite();
    this.generateNPCSprites();
    this.generateTileTextures();
    this.generateFurnitureSprites();
    this.generateUIElements();
    
    // Hide loading screen
    document.getElementById('loading').classList.add('hidden');
    
    // Start title
    this.scene.start('Title');
  }
  
  generatePlayerSprite() {
    const g = this.add.graphics();
    // 4 directions Ã— 2 frames = 8 frames, each 32Ã—32
    const dirs = [
      { name: 'down', body: true },
      { name: 'up', body: true },
      { name: 'left', body: true },
      { name: 'right', body: true }
    ];
    
    dirs.forEach((dir, di) => {
      for (let frame = 0; frame < 2; frame++) {
        g.clear();
        const ox = (di * 2 + frame) * TILE;
        const wobble = frame === 1 ? 1 : 0;
        
        // Body
        g.fillStyle(Save.data.avatar.outfit);
        g.fillRect(ox + 8, 14 + wobble, 16, 12);
        
        // Head
        g.fillStyle(Save.data.avatar.skin);
        g.fillRect(ox + 9, 4 + wobble, 14, 12);
        
        // Eyes
        g.fillStyle(0x0a0a0f);
        if (dir.name === 'up') {
          // No eyes from behind
        } else if (dir.name === 'left') {
          g.fillRect(ox + 10, 8 + wobble, 3, 3);
        } else if (dir.name === 'right') {
          g.fillRect(ox + 19, 8 + wobble, 3, 3);
        } else {
          g.fillRect(ox + 12, 8 + wobble, 3, 3);
          g.fillRect(ox + 18, 8 + wobble, 3, 3);
        }
        
        // Legs
        g.fillStyle(0x1a1a2e);
        const legOff = frame === 1 ? 2 : 0;
        g.fillRect(ox + 10, 26, 5, 6 - legOff);
        g.fillRect(ox + 17, 26, 5, 6 - (frame === 0 ? 2 : 0));
      }
    });
    
    g.generateTexture('player', TILE * 8, TILE);
    g.destroy();
  }
  
  generateNPCSprites() {
    const npcs = [
      { key: 'npc_pixel', skin: 0x00f0ff, outfit: 0xff6b9d },
      { key: 'npc_nova', skin: 0xa855f7, outfit: 0x2a2a4e },
      { key: 'npc_glitch', skin: 0x00ff88, outfit: 0x1a3a1a },
      { key: 'npc_echo', skin: 0xffe600, outfit: 0x3a3a1a },
      { key: 'npc_byte', skin: 0xff00aa, outfit: 0x2a1a2e },
      { key: 'npc_circuit', skin: 0x7b5cff, outfit: 0x1a1a3a },
    ];
    
    npcs.forEach(npc => {
      const g = this.add.graphics();
      for (let frame = 0; frame < 2; frame++) {
        g.clear();
        const ox = frame * TILE;
        const wobble = frame === 1 ? 1 : 0;
        
        g.fillStyle(npc.outfit);
        g.fillRect(ox + 8, 14 + wobble, 16, 12);
        g.fillStyle(npc.skin);
        g.fillRect(ox + 9, 4 + wobble, 14, 12);
        g.fillStyle(0x0a0a0f);
        g.fillRect(ox + 12, 8 + wobble, 3, 3);
        g.fillRect(ox + 18, 8 + wobble, 3, 3);
        g.fillStyle(0x1a1a2e);
        g.fillRect(ox + 10, 26, 5, 6);
        g.fillRect(ox + 17, 26, 5, 6);
      }
      g.generateTexture(npc.key, TILE * 2, TILE);
      g.destroy();
    });
  }
  
  generateTileTextures() {
    // Road tile
    let g = this.add.graphics();
    g.fillStyle(0x080810);
    g.fillRect(0, 0, TILE, TILE);
    g.lineStyle(1, 0x111126, 0.3);
    g.strokeRect(0, 0, TILE, TILE);
    // Road line
    g.fillStyle(0xffe600, 0.15);
    g.fillRect(14, 0, 4, TILE);
    g.generateTexture('tile_road', TILE, TILE);
    g.destroy();
    
    // Sidewalk
    g = this.add.graphics();
    g.fillStyle(0x0d0d18);
    g.fillRect(0, 0, TILE, TILE);
    g.lineStyle(1, 0x00f0ff, 0.06);
    g.strokeRect(0, 0, TILE, TILE);
    g.generateTexture('tile_sidewalk', TILE, TILE);
    g.destroy();
    
    // Building wall
    g = this.add.graphics();
    g.fillStyle(0x0a0a1a);
    g.fillRect(0, 0, TILE, TILE);
    g.lineStyle(1, 0x00f0ff, 0.12);
    g.strokeRect(0, 0, TILE, TILE);
    // Window
    g.fillStyle(0x00f0ff, 0.15);
    g.fillRect(10, 8, 12, 10);
    g.generateTexture('tile_building', TILE, TILE);
    g.destroy();
    
    // Door
    g = this.add.graphics();
    g.fillStyle(0x0d0d18);
    g.fillRect(0, 0, TILE, TILE);
    g.lineStyle(2, 0x00f0ff, 0.6);
    g.strokeRect(6, 2, 20, 28);
    g.fillStyle(0x00f0ff, 0.2);
    g.fillRect(8, 4, 16, 24);
    // Arrow indicator
    g.fillStyle(0x00f0ff, 0.8);
    g.fillTriangle(16, 0, 12, 6, 20, 6);
    g.generateTexture('tile_door', TILE, TILE);
    g.destroy();
    
    // Park grass
    g = this.add.graphics();
    g.fillStyle(0x0a1a0f);
    g.fillRect(0, 0, TILE, TILE);
    g.lineStyle(1, 0x00ff88, 0.05);
    g.strokeRect(0, 0, TILE, TILE);
    g.generateTexture('tile_park', TILE, TILE);
    g.destroy();
    
    // Plaza
    g = this.add.graphics();
    g.fillStyle(0x0d0d1a);
    g.fillRect(0, 0, TILE, TILE);
    g.lineStyle(1, 0xff00aa, 0.06);
    g.strokeRect(0, 0, TILE, TILE);
    g.generateTexture('tile_plaza', TILE, TILE);
    g.destroy();
    
    // Neon tree
    g = this.add.graphics();
    g.fillStyle(0x00ff88, 0.3);
    g.fillCircle(16, 10, 10);
    g.fillStyle(0x1a3a1a);
    g.fillRect(14, 18, 4, 14);
    g.generateTexture('tree', TILE, TILE);
    g.destroy();
    
    // Room floor
    g = this.add.graphics();
    g.fillStyle(0x0a0a14);
    g.fillRect(0, 0, TILE, TILE);
    g.lineStyle(1, 0x00f0ff, 0.04);
    g.strokeRect(0, 0, TILE, TILE);
    g.generateTexture('tile_floor', TILE, TILE);
    g.destroy();
    
    // Room wall
    g = this.add.graphics();
    g.fillStyle(0x0d0d20);
    g.fillRect(0, 0, TILE, TILE);
    g.lineStyle(1, 0x00f0ff, 0.08);
    g.strokeRect(0, 0, TILE, TILE);
    g.generateTexture('tile_wall', TILE, TILE);
    g.destroy();
  }
  
  generateFurnitureSprites() {
    FURNITURE.forEach(f => {
      const g = this.add.graphics();
      const w = f.w * TILE;
      const h = f.h * TILE;
      
      // Base shape
      g.fillStyle(0x0a0a1a);
      g.fillRect(0, 0, w, h);
      g.lineStyle(2, f.color, 0.7);
      g.strokeRect(1, 1, w - 2, h - 2);
      
      // Inner detail varies by item
      g.fillStyle(f.color, 0.15);
      g.fillRect(3, 3, w - 6, h - 6);
      
      // Icon letter
      g.fillStyle(f.color, 0.6);
      // Simple icon based on type
      const cx = w / 2, cy = h / 2;
      switch(f.id) {
        case 'pc':
          g.fillRect(6, 4, 20, 16); // screen
          g.fillStyle(f.color, 0.3);
          g.fillRect(12, 22, 8, 4); // stand
          break;
        case 'speaker':
          g.fillStyle(f.color, 0.3);
          g.fillCircle(cx, cy - 2, 8);
          g.fillCircle(cx, cy + 8, 5);
          break;
        case 'plant':
          g.fillStyle(0x00ff88, 0.4);
          g.fillCircle(cx, 8, 10);
          g.fillStyle(0x1a1a2e);
          g.fillRect(12, 20, 8, 10);
          break;
        case 'hologram':
          g.fillStyle(f.color, 0.2);
          g.fillTriangle(cx, 4, 4, h - 8, w - 4, h - 8);
          break;
        case 'disco':
          g.fillStyle(f.color, 0.4);
          g.fillCircle(cx, cy, 12);
          g.fillStyle(0xffffff, 0.2);
          g.fillCircle(cx - 4, cy - 4, 3);
          break;
        case 'lamp':
          g.fillStyle(f.color, 0.4);
          g.fillTriangle(cx, 2, cx - 8, 14, cx + 8, 14);
          g.fillStyle(0x333333);
          g.fillRect(cx - 2, 14, 4, 16);
          break;
        default:
          g.fillStyle(f.color, 0.2);
          g.fillRect(4, 4, w - 8, h - 8);
      }
      
      g.generateTexture('furn_' + f.id, w, h);
      g.destroy();
    });
  }
  
  generateUIElements() {
    // Interaction prompt
    const g = this.add.graphics();
    g.fillStyle(0x0a0a0f, 0.85);
    g.fillRoundedRect(0, 0, 160, 32, 4);
    g.lineStyle(1, 0x00f0ff, 0.5);
    g.strokeRoundedRect(0, 0, 160, 32, 4);
    g.generateTexture('ui_prompt', 160, 32);
    g.destroy();
  }
}

// ============================================================
// TITLE SCENE
// ============================================================
class TitleScene extends Phaser.Scene {
  constructor() { super('Title'); }
  
  create() {
    const cx = this.cameras.main.centerX;
    const cy = this.cameras.main.centerY;
    
    // Background
    this.cameras.main.setBackgroundColor(0x0a0a0f);
    
    // Animated grid
    for (let i = 0; i < 20; i++) {
      const line = this.add.rectangle(cx, i * 40, 800, 1, COLORS.cyan, 0.03);
      this.tweens.add({ targets: line, alpha: { from: 0.01, to: 0.06 }, duration: 2000, yoyo: true, repeat: -1, delay: i * 100 });
    }
    
    // CF Logo
    const cText = this.add.text(cx - 40, cy - 120, 'C', {
      fontFamily: 'Orbitron', fontSize: '80px', fontStyle: 'bold', color: '#00f0ff'
    }).setOrigin(0.5).setShadow(0, 0, '#00f0ff', 10);
    
    const fText = this.add.text(cx + 10, cy - 120, 'F', {
      fontFamily: 'Orbitron', fontSize: '80px', fontStyle: 'bold', color: '#ff00aa'
    }).setOrigin(0.5).setShadow(0, 0, '#ff00aa', 10);
    
    // Title
    this.add.text(cx, cy - 40, 'CYBR FRNDZ', {
      fontFamily: 'Orbitron', fontSize: '36px', fontStyle: 'bold', color: '#ffffff'
    }).setOrigin(0.5).setShadow(0, 0, '#00f0ff', 8);
    
    // Subtitle
    this.add.text(cx, cy + 10, 'EARN RESPECT. BUILD YOUR WORLD.', {
      fontFamily: 'Share Tech Mono', fontSize: '14px', color: '#8888aa'
    }).setOrigin(0.5);
    
    // Start prompt
    const start = this.add.text(cx, cy + 80, '[ TAP TO START ]', {
      fontFamily: 'Orbitron', fontSize: '16px', color: '#00f0ff'
    }).setOrigin(0.5);
    
    this.tweens.add({ targets: start, alpha: { from: 1, to: 0.3 }, duration: 800, yoyo: true, repeat: -1 });
    
    // Version
    this.add.text(cx, cy + 160, 'v0.1 â€” EARLY ACCESS', {
      fontFamily: 'Share Tech Mono', fontSize: '10px', color: '#444466'
    }).setOrigin(0.5);
    
    // Click/tap to start
    this.input.once('pointerdown', () => {
      this.cameras.main.fadeOut(500, 10, 10, 15);
      this.time.delayedCall(500, () => this.scene.start('City'));
    });
    
    // Keyboard
    this.input.keyboard.once('keydown', () => {
      this.cameras.main.fadeOut(500, 10, 10, 15);
      this.time.delayedCall(500, () => this.scene.start('City'));
    });
  }
}

// ============================================================
// CITY SCENE â€” Overworld
// ============================================================
class CityScene extends Phaser.Scene {
  constructor() { super('City'); }
  
  create() {
    this.cameras.main.fadeIn(500);
    this.cameras.main.setBackgroundColor(0x0a0a0f);
    
    const { map, buildings } = cityData;
    
    // Render tilemap
    this.tileSprites = this.add.group();
    const tileKeys = ['tile_road', 'tile_sidewalk', 'tile_building', 'tile_park', 'tile_door', 'tile_plaza'];
    
    for (let y = 0; y < CITY_H; y++) {
      for (let x = 0; x < CITY_W; x++) {
        const tileType = map[y][x];
        const key = tileKeys[tileType] || 'tile_road';
        this.add.image(x * TILE + TILE/2, y * TILE + TILE/2, key);
      }
    }
    
    // Building labels
    buildings.forEach(b => {
      // Neon outline around building
      const rect = this.add.rectangle(
        b.x * TILE + (b.w * TILE) / 2,
        b.y * TILE + (b.h * TILE) / 2,
        b.w * TILE, b.h * TILE
      );
      rect.setStrokeStyle(2, b.color, 0.5);
      rect.setFillStyle(0, 0);
      
      // Pulsing glow
      this.tweens.add({
        targets: rect, 
        strokeAlpha: { from: 0.3, to: 0.8 },
        duration: 2000, yoyo: true, repeat: -1
      });
      
      // Label
      this.add.text(
        b.x * TILE + (b.w * TILE) / 2,
        b.y * TILE - 8,
        b.name,
        { fontFamily: 'Share Tech Mono', fontSize: '9px', color: '#' + b.color.toString(16).padStart(6, '0') }
      ).setOrigin(0.5).setShadow(0, 0, '#' + b.color.toString(16).padStart(6, '0'), 4);
    });
    
    // Park trees
    for (let i = 0; i < 12; i++) {
      const tx = (5 + Math.floor(Math.random() * 11)) * TILE + TILE/2;
      const ty = (20 + Math.floor(Math.random() * 5)) * TILE + TILE/2;
      const tree = this.add.image(tx, ty, 'tree');
      this.tweens.add({
        targets: tree, alpha: { from: 0.6, to: 1 },
        duration: 1500 + Math.random() * 1000, yoyo: true, repeat: -1
      });
    }
    
    // NPC sprites in the world
    this.npcs = [];
    const npcPositions = [
      { key: 'pixel', x: 10, y: 8, spriteKey: 'npc_pixel' },
      { key: 'nova', x: 7, y: 16, spriteKey: 'npc_nova' },
      { key: 'glitch', x: 17, y: 16, spriteKey: 'npc_glitch' },
      { key: 'echo', x: 27, y: 8, spriteKey: 'npc_echo' },
      { key: 'byte', x: 27, y: 16, spriteKey: 'npc_byte' },
      { key: 'mrs_circuit', x: 25, y: 22, spriteKey: 'npc_circuit' },
    ];
    
    npcPositions.forEach(n => {
      const sprite = this.add.sprite(n.x * TILE + TILE/2, n.y * TILE + TILE/2, n.spriteKey, 0);
      sprite.npcKey = n.key;
      
      // Idle animation (wobble)
      this.tweens.add({
        targets: sprite, y: sprite.y - 2,
        duration: 1000 + Math.random() * 500, yoyo: true, repeat: -1
      });
      
      // Name tag
      const color = DIALOGUES[n.key]?.color || 0x00f0ff;
      this.add.text(n.x * TILE + TILE/2, n.y * TILE - 8, 
        DIALOGUES[n.key]?.emoji + ' ' + (DIALOGUES[n.key]?.name || n.key),
        { fontFamily: 'Share Tech Mono', fontSize: '8px', color: '#' + color.toString(16).padStart(6, '0') }
      ).setOrigin(0.5);
      
      this.npcs.push({ sprite, key: n.key, x: n.x, y: n.y });
    });
    
    // Player
    this.playerX = 7;
    this.playerY = 8;
    this.player = this.add.sprite(
      this.playerX * TILE + TILE/2,
      this.playerY * TILE + TILE/2,
      'player', 0
    );
    this.player.setDepth(10);
    this.playerDir = 0; // 0=down,1=up,2=left,3=right
    this.playerFrame = 0;
    this.walkTimer = 0;
    this.isMoving = false;
    
    // Camera
    this.cameras.main.startFollow(this.player, true, 0.08, 0.08);
    this.cameras.main.setZoom(2);
    
    // Controls
    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys('W,A,S,D');
    this.interactKey = this.input.keyboard.addKey('E');
    
    // HUD (fixed to camera)
    this.createHUD();
    
    // Interaction prompt
    this.promptText = this.add.text(0, 0, '', {
      fontFamily: 'Share Tech Mono', fontSize: '8px', color: '#00f0ff'
    }).setOrigin(0.5).setDepth(20).setVisible(false);
    
    // Dialogue state
    this.dialogueActive = false;
    this.dialogueBox = null;
    
    // Touch controls for mobile
    this.createMobileControls();
    
    // Movement input state for mobile
    this.mobileDir = { x: 0, y: 0 };
  }
  
  createHUD() {
    const cam = this.cameras.main;
    
    // RP display
    this.rpText = this.add.text(10, 10, '', {
      fontFamily: 'Orbitron', fontSize: '10px', color: '#00f0ff'
    }).setScrollFactor(0).setDepth(100);
    
    // Location
    this.locText = this.add.text(10, 24, 'ðŸ“ NEON DISTRICT', {
      fontFamily: 'Share Tech Mono', fontSize: '8px', color: '#8888aa'
    }).setScrollFactor(0).setDepth(100);
    
    this.updateHUD();
  }
  
  createMobileControls() {
    if (!this.sys.game.device.input.touch) return;
    
    const w = this.cameras.main.width;
    const h = this.cameras.main.height;
    const padX = 60;
    const padY = h - 60;
    const btnSize = 36;
    
    const dirs = [
      { x: 0, y: -btnSize, label: 'â–²', dx: 0, dy: -1 },
      { x: 0, y: btnSize, label: 'â–¼', dx: 0, dy: 1 },
      { x: -btnSize, y: 0, label: 'â—„', dx: -1, dy: 0 },
      { x: btnSize, y: 0, label: 'â–º', dx: 1, dy: 0 },
    ];
    
    dirs.forEach(d => {
      const btn = this.add.text(padX + d.x, padY + d.y, d.label, {
        fontFamily: 'Orbitron', fontSize: '20px', color: '#00f0ff', backgroundColor: '#0a0a0f88',
        padding: { x: 8, y: 4 }
      }).setOrigin(0.5).setScrollFactor(0).setDepth(100).setInteractive().setAlpha(0.6);
      
      btn.on('pointerdown', () => { this.mobileDir = { x: d.dx, y: d.dy }; btn.setAlpha(1); });
      btn.on('pointerup', () => { this.mobileDir = { x: 0, y: 0 }; btn.setAlpha(0.6); });
      btn.on('pointerout', () => { this.mobileDir = { x: 0, y: 0 }; btn.setAlpha(0.6); });
    });
    
    // Interact button
    const eBtn = this.add.text(w - 50, h - 60, 'E', {
      fontFamily: 'Orbitron', fontSize: '18px', color: '#ff00aa', backgroundColor: '#0a0a0f88',
      padding: { x: 12, y: 8 }
    }).setOrigin(0.5).setScrollFactor(0).setDepth(100).setInteractive().setAlpha(0.6);
    
    eBtn.on('pointerdown', () => { this.handleInteraction(); eBtn.setAlpha(1); });
    eBtn.on('pointerup', () => eBtn.setAlpha(0.6));
  }
  
  updateHUD() {
    this.rpText.setText('âš¡ ' + Save.data.rp + ' RP');
  }
  
  update(time, delta) {
    if (this.dialogueActive) return;
    
    // Movement
    this.walkTimer += delta;
    const moveDelay = 150; // ms per tile
    
    if (this.walkTimer >= moveDelay) {
      let dx = 0, dy = 0;
      
      if (this.cursors.left.isDown || this.wasd.A.isDown || this.mobileDir.x < 0) { dx = -1; this.playerDir = 2; }
      else if (this.cursors.right.isDown || this.wasd.D.isDown || this.mobileDir.x > 0) { dx = 1; this.playerDir = 3; }
      else if (this.cursors.up.isDown || this.wasd.W.isDown || this.mobileDir.y < 0) { dy = -1; this.playerDir = 1; }
      else if (this.cursors.down.isDown || this.wasd.S.isDown || this.mobileDir.y > 0) { dy = 1; this.playerDir = 0; }
      
      if (dx !== 0 || dy !== 0) {
        const nx = this.playerX + dx;
        const ny = this.playerY + dy;
        
        // Bounds check
        if (nx >= 0 && nx < CITY_W && ny >= 0 && ny < CITY_H) {
          const tile = cityData.map[ny][nx];
          // Can walk on road(0), sidewalk(1), door(4), park(3), plaza(5)
          if (tile !== 2) {
            this.playerX = nx;
            this.playerY = ny;
            
            // Animate walk
            this.playerFrame = (this.playerFrame + 1) % 2;
            this.player.setFrame(this.playerDir * 2 + this.playerFrame);
            
            // Smooth movement
            this.tweens.add({
              targets: this.player,
              x: nx * TILE + TILE/2,
              y: ny * TILE + TILE/2,
              duration: moveDelay - 10,
              ease: 'Linear'
            });
          }
        }
        this.walkTimer = 0;
      }
    }
    
    // Check for nearby interactions
    this.checkInteractions();
    
    // E key interaction
    if (Phaser.Input.Keyboard.JustDown(this.interactKey)) {
      this.handleInteraction();
    }
  }
  
  checkInteractions() {
    let nearDoor = null;
    let nearNPC = null;
    
    // Check doors
    cityData.buildings.forEach(b => {
      if (Math.abs(this.playerX - b.doorX) <= 1 && Math.abs(this.playerY - b.doorY) <= 1) {
        nearDoor = b;
      }
    });
    
    // Check NPCs
    this.npcs.forEach(n => {
      if (Math.abs(this.playerX - n.x) <= 1 && Math.abs(this.playerY - n.y) <= 1) {
        nearNPC = n;
      }
    });
    
    this.nearDoor = nearDoor;
    this.nearNPC = nearNPC;
    
    if (nearDoor) {
      this.promptText.setVisible(true);
      this.promptText.setText('[E] Enter ' + nearDoor.name);
      this.promptText.setPosition(this.player.x, this.player.y - 24);
    } else if (nearNPC) {
      this.promptText.setVisible(true);
      this.promptText.setText('[E] Talk to ' + (DIALOGUES[nearNPC.key]?.name || nearNPC.key));
      this.promptText.setPosition(this.player.x, this.player.y - 24);
    } else {
      this.promptText.setVisible(false);
    }
  }
  
  handleInteraction() {
    if (this.nearDoor) {
      const b = this.nearDoor;
      this.cameras.main.fadeOut(300, 10, 10, 15);
      this.time.delayedCall(300, () => {
        this.scene.start('Apartment', { 
          buildingId: b.id, 
          name: b.name, 
          color: b.color,
          isPlayer: b.id === 'player',
          npcRoom: NPC_ROOMS[b.id] || null
        });
      });
    } else if (this.nearNPC && !this.dialogueActive) {
      this.startDialogue(this.nearNPC.key);
    }
  }
  
  startDialogue(npcKey) {
    const dlg = DIALOGUES[npcKey];
    if (!dlg) return;
    
    this.dialogueActive = true;
    this.dialogueIndex = 0;
    
    // Create dialogue box
    const cam = this.cameras.main;
    const boxW = cam.width / cam.zoom - 20;
    const boxH = 70;
    const boxX = this.player.x;
    const boxY = this.player.y + 40;
    
    this.dlgBg = this.add.rectangle(boxX, boxY, boxW, boxH, 0x0a0a0f, 0.92)
      .setStrokeStyle(1, dlg.color, 0.6).setDepth(50);
    
    this.dlgName = this.add.text(boxX - boxW/2 + 8, boxY - boxH/2 + 6, 
      dlg.emoji + ' ' + dlg.name, {
      fontFamily: 'Orbitron', fontSize: '8px', 
      color: '#' + dlg.color.toString(16).padStart(6, '0')
    }).setDepth(51);
    
    this.dlgText = this.add.text(boxX - boxW/2 + 8, boxY - boxH/2 + 20, 
      dlg.lines[0].text, {
      fontFamily: 'Share Tech Mono', fontSize: '8px', color: '#e0e0f0',
      wordWrap: { width: boxW - 16 }
    }).setDepth(51);
    
    this.dlgContinue = this.add.text(boxX, boxY + boxH/2 - 10, 
      '[TAP / E TO CONTINUE]', {
      fontFamily: 'Share Tech Mono', fontSize: '6px', color: '#8888aa'
    }).setOrigin(0.5).setDepth(51);
    
    this.tweens.add({ targets: this.dlgContinue, alpha: { from: 1, to: 0.4 }, duration: 600, yoyo: true, repeat: -1 });
    
    this.currentDialogue = dlg;
    
    // Advance on click/key
    const advance = () => {
      this.dialogueIndex++;
      if (this.dialogueIndex >= dlg.lines.length) {
        this.endDialogue(npcKey);
      } else {
        this.dlgText.setText(dlg.lines[this.dialogueIndex].text);
      }
    };
    
    this.input.once('pointerdown', advance);
    this.interactKey.once('down', advance);
    
    // Re-bind for subsequent advances
    const bindNext = () => {
      if (!this.dialogueActive) return;
      this.input.once('pointerdown', () => { advance(); bindNext(); });
      this.interactKey.once('down', () => { advance(); bindNext(); });
    };
    bindNext();
  }
  
  endDialogue(npcKey) {
    this.dialogueActive = false;
    if (this.dlgBg) this.dlgBg.destroy();
    if (this.dlgName) this.dlgName.destroy();
    if (this.dlgText) this.dlgText.destroy();
    if (this.dlgContinue) this.dlgContinue.destroy();
    
    // Quest reward on last dialogue
    const dlg = DIALOGUES[npcKey];
    if (dlg?.quest && !Save.data.quests[dlg.quest.id]) {
      Save.data.quests[dlg.quest.id] = { accepted: true, progress: 0 };
      Save.save();
    }
    
    // Track visited
    if (!Save.data.visited[npcKey]) {
      Save.data.visited[npcKey] = true;
      Save.save();
    }
  }
}

// ============================================================
// APARTMENT SCENE â€” Room Decorator
// ============================================================
class ApartmentScene extends Phaser.Scene {
  constructor() { super('Apartment'); }
  
  create(data) {
    this.cameras.main.fadeIn(300);
    this.cameras.main.setBackgroundColor(0x0a0a0f);
    
    this.buildingId = data.buildingId;
    this.isPlayer = data.isPlayer;
    this.roomColor = data.color;
    
    const ROOM_W = 12;
    const ROOM_H = 8;
    this.roomW = ROOM_W;
    this.roomH = ROOM_H;
    
    // Draw room
    // Wall (top 2 rows)
    for (let x = 0; x < ROOM_W; x++) {
      for (let y = 0; y < 2; y++) {
        this.add.image(x * TILE + TILE/2, y * TILE + TILE/2, 'tile_wall');
      }
    }
    // Floor
    for (let x = 0; x < ROOM_W; x++) {
      for (let y = 2; y < ROOM_H; y++) {
        this.add.image(x * TILE + TILE/2, y * TILE + TILE/2, 'tile_floor');
      }
    }
    
    // Room border (neon outline)
    const border = this.add.rectangle(
      ROOM_W * TILE / 2, ROOM_H * TILE / 2,
      ROOM_W * TILE, ROOM_H * TILE
    );
    border.setStrokeStyle(2, this.roomColor, 0.6);
    border.setFillStyle(0, 0);
    
    // Room name
    this.add.text(ROOM_W * TILE / 2, -12, data.name, {
      fontFamily: 'Orbitron', fontSize: '12px',
      color: '#' + this.roomColor.toString(16).padStart(6, '0')
    }).setOrigin(0.5).setShadow(0, 0, '#' + this.roomColor.toString(16).padStart(6, '0'), 6);
    
    // Place furniture
    this.placedItems = this.add.group();
    
    if (this.isPlayer) {
      // Load saved room
      (Save.data.room || []).forEach(item => {
        this.placeFurniture(item.id, item.x, item.y, false);
      });
    } else if (data.npcRoom) {
      // NPC pre-decorated room
      data.npcRoom.forEach(item => {
        this.placeFurniture(item.id, item.x, item.y, false);
      });
    }
    
    // Camera
    this.cameras.main.setZoom(2.5);
    this.cameras.main.centerOn(ROOM_W * TILE / 2, ROOM_H * TILE / 2);
    
    // HUD
    this.rpText = this.add.text(10, 10, '', {
      fontFamily: 'Orbitron', fontSize: '10px', color: '#00f0ff'
    }).setScrollFactor(0).setDepth(100);
    
    // Back button
    const backBtn = this.add.text(10, this.cameras.main.height / this.cameras.main.zoom - 16, 'â† BACK [ESC]', {
      fontFamily: 'Share Tech Mono', fontSize: '8px', color: '#ff00aa',
      backgroundColor: '#0a0a0f88', padding: { x: 4, y: 2 }
    }).setScrollFactor(0).setDepth(100).setInteractive();
    
    backBtn.on('pointerdown', () => this.exitRoom());
    this.input.keyboard.on('keydown-ESC', () => this.exitRoom());
    
    // Inventory (player room only)
    if (this.isPlayer) {
      this.createInventoryUI();
      this.selectedFurniture = null;
      this.placementGrid = null;
      
      // Click to place
      this.input.on('pointerdown', (pointer) => {
        if (this.selectedFurniture && !pointer.wasTouch) {
          const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
          const gx = Math.floor(worldPoint.x / TILE);
          const gy = Math.floor(worldPoint.y / TILE);
          if (gx >= 0 && gx < ROOM_W && gy >= 0 && gy < ROOM_H) {
            this.buyAndPlace(this.selectedFurniture, gx, gy);
          }
        }
      });
    }
    
    this.updateHUD();
  }
  
  createInventoryUI() {
    const startY = 30;
    this.invItems = [];
    
    // Inventory label
    this.add.text(this.cameras.main.width / this.cameras.main.zoom - 4, (startY - 10) / this.cameras.main.zoom, 'SHOP', {
      fontFamily: 'Orbitron', fontSize: '7px', color: '#ff00aa'
    }).setOrigin(1, 0).setScrollFactor(0).setDepth(100);
    
    const panelW = 70;
    const camW = this.cameras.main.width / this.cameras.main.zoom;
    
    FURNITURE.slice(0, 12).forEach((f, i) => {
      const row = Math.floor(i / 2);
      const col = i % 2;
      const bx = camW - panelW + col * 35 + 10;
      const by = startY / this.cameras.main.zoom + row * 18;
      
      const btn = this.add.text(bx, by, f.name.substring(0, 6), {
        fontFamily: 'Share Tech Mono', fontSize: '6px', color: '#8888aa',
        backgroundColor: '#0a0a1a', padding: { x: 2, y: 1 }
      }).setScrollFactor(0).setDepth(100).setInteractive();
      
      const cost = this.add.text(bx, by + 9, f.cost + 'rp', {
        fontFamily: 'Share Tech Mono', fontSize: '5px', color: '#00f0ff'
      }).setScrollFactor(0).setDepth(100);
      
      btn.on('pointerdown', () => {
        this.selectedFurniture = f.id;
        this.invItems.forEach(item => item.btn.setColor('#8888aa'));
        btn.setColor('#00f0ff');
      });
      
      btn.on('pointerover', () => btn.setColor('#00f0ff'));
      btn.on('pointerout', () => {
        if (this.selectedFurniture !== f.id) btn.setColor('#8888aa');
      });
      
      this.invItems.push({ btn, cost, furniture: f });
    });
  }
  
  placeFurniture(id, gx, gy, animate = true) {
    const f = FURNITURE.find(f => f.id === id);
    if (!f) return;
    
    const sprite = this.add.image(
      gx * TILE + (f.w * TILE) / 2,
      gy * TILE + (f.h * TILE) / 2,
      'furn_' + id
    ).setDepth(5);
    
    if (animate) {
      sprite.setScale(0.5).setAlpha(0.5);
      this.tweens.add({
        targets: sprite,
        scale: 1, alpha: 1,
        duration: 300,
        ease: 'Back.easeOut'
      });
    }
    
    sprite.setData('furnitureId', id);
    sprite.setData('gridX', gx);
    sprite.setData('gridY', gy);
    this.placedItems.add(sprite);
    
    return sprite;
  }
  
  buyAndPlace(furnitureId, gx, gy) {
    const f = FURNITURE.find(f => f.id === furnitureId);
    if (!f) return;
    
    // Check bounds
    if (gx + f.w > this.roomW || gy + f.h > this.roomH) return;
    
    // Check RP
    if (!Save.spendRP(f.cost)) {
      // Flash RP text red
      this.rpText.setColor('#ff0000');
      this.time.delayedCall(300, () => this.rpText.setColor('#00f0ff'));
      return;
    }
    
    this.placeFurniture(furnitureId, gx, gy, true);
    
    // Save
    Save.data.room.push({ id: furnitureId, x: gx, y: gy });
    Save.save();
    
    // Update quest progress
    if (Save.data.quests.pixel_decorate) {
      Save.data.quests.pixel_decorate.progress = Save.data.room.length;
      if (Save.data.room.length >= 5 && !Save.data.quests.pixel_decorate.completed) {
        Save.data.quests.pixel_decorate.completed = true;
        Save.earnRP(50);
        // TODO: show quest complete notification
      }
      Save.save();
    }
    
    this.updateHUD();
  }
  
  updateHUD() {
    this.rpText.setText('âš¡ ' + Save.data.rp + ' RP');
  }
  
  exitRoom() {
    this.cameras.main.fadeOut(300, 10, 10, 15);
    this.time.delayedCall(300, () => this.scene.start('City'));
  }
}

// ============================================================
// PHASER CONFIG
// ============================================================
const config = {
  type: Phaser.AUTO,
  parent: 'game-container',
  width: 800,
  height: 600,
  pixelArt: true,
  backgroundColor: '#0a0a0f',
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
  },
  scene: [BootScene, TitleScene, CityScene, ApartmentScene],
};

const game = new Phaser.Game(config);

</script>
</body>
</html>
